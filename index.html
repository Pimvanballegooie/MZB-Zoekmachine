<!doctype html>
<html lang="nl">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Monné Zoekmachine — Locatie & (Sub)Categorie met Match%</title>
<style>
  :root{
    --bg:#0b1020; --panel:#0f172a; --muted:#94a3b8; --text:#e5e7eb;
    --border:#1f2937; --chip:#162039; --chip-b:#22314f;
    --accent:#f97316; --good:#22c55e; --warn:#eab308; --bad:#f43f5e;
  }
  html,body{margin:0;background:var(--bg);color:var(--text);font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Arial}
  .container{max-width:1200px;margin:0 auto;padding:24px}
  header{display:flex;align-items:center;justify-content:space-between;margin-bottom:12px}
  h1{margin:0;font-size:clamp(18px,2.3vw,28px)}
  .brand{display:flex;gap:10px;align-items:center}
  .logo{width:36px;height:36px;border-radius:8px;background:var(--accent)}
  .sub{color:var(--muted)}
  .panel{background:var(--panel);border:1px solid var(--border);border-radius:16px;padding:16px;margin:12px 0}
  .grid{display:grid;gap:12px}
  @media(min-width:1000px){.grid-3{grid-template-columns:1fr 1fr 1fr}}
  label{display:block;font-size:13px;color:var(--muted);margin-bottom:6px}
  input[type="text"],select{width:100%;padding:10px 12px;border-radius:12px;border:1px solid var(--border);background:#0b1220;color:var(--text)}
  .btn{padding:10px 14px;border-radius:12px;border:1px solid var(--border);background:#0b1220;color:var(--text);cursor:pointer}
  .btn:hover{border-color:#2a3b5f}
  .btn-accent{background:var(--accent);border-color:#ef7d2a;color:#0b1020;font-weight:600}
  .chips{display:flex;gap:8px;flex-wrap:wrap;margin-top:8px}
  .chip{background:var(--chip);border:1px solid var(--chip-b);padding:6px 10px;border-radius:999px;font-size:12px}
  .chip .x{margin-left:6px;cursor:pointer;opacity:.7}
  .row{display:flex;gap:10px;flex-wrap:wrap}
  .status{font-size:13px;color:var(--muted);margin:6px 0}
  .status.error{color:var(--bad)}
  .typeahead{position:relative}
  .suggest{position:absolute;z-index:20;top:100%;left:0;right:0;background:#0b1220;border:1px solid var(--border);border-radius:12px;max-height:260px;overflow:auto}
  .suggest div{padding:8px 10px;border-bottom:1px solid #0e172b;cursor:pointer}
  .suggest div:hover{background:#101a32}
  .tag{font-size:11px;opacity:.8}
  table{width:100%;border-collapse:separate;border-spacing:0 10px;margin-top:12px}
  thead th{text-align:left;font-size:12px;color:var(--muted);padding:0 12px}
  tbody tr{background:#0b1220;border:1px solid var(--border)}
  td{padding:12px;vertical-align:top}
  .name{font-weight:600}
  .meter{height:10px;background:#0e162b;border-radius:999px;overflow:hidden;border:1px solid var(--border)}
  .bar{height:100%;background:linear-gradient(90deg,var(--accent),#f59e0b)}
  .kpi{display:flex;gap:10px;align-items:center}
  .badge{display:inline-block;padding:4px 8px;border-radius:999px;border:1px solid var(--chip-b);background:var(--chip);font-size:11px;margin-right:6px}
  .good{border-color:#1b7f3d;background:#0f2a1c;color:#a7f3d0}
  .warn{border-color:#7c6a12;background:#2a240f;color:#fde68a}
  .bad{border-color:#7f1d1d;background:#2a1111;color:#fecaca}
  .muted{color:var(--muted)}
  details.debug{font-size:12px;color:var(--muted)}
  details.debug summary{cursor:pointer}
  .kv{display:grid;grid-template-columns:auto 1fr;gap:6px}
</style>
</head>
<body>
<div class="container">
  <header>
    <div class="brand">
      <div class="logo"></div>
      <div>
        <h1>Monné Zoekmachine</h1>
        <div class="sub">Locatie & (Sub)Categorie — Slim zoeken met match%</div>
      </div>
    </div>
    <div class="row">
      <button id="refresh" class="btn-accent">Vernieuw data</button>
      <button id="toggleDebug" class="btn">Debug</button>
    </div>
  </header>

  <div id="statusBar" class="status"></div>

  <div class="panel">
    <div class="grid grid-3">
      <div>
        <label>Locatie (vrij zoeken)</label>
        <input id="locFree" type="text" placeholder="Typ bijv. 'Belcrum' of 'Ginneken'">
      </div>
      <div>
        <label>Locatie (selectie)</label>
        <select id="locSelect" size="6" multiple></select>
      </div>
      <div>
        <label>Categorie-zoeker (intelligent: hoofd & sub)</label>
        <div class="typeahead">
          <input id="catInput" type="text" placeholder="Typ bijv. 'Kinder' of 'Benen' of 'Schouder'">
          <div id="suggest" class="suggest" style="display:none;"></div>
        </div>
        <div class="chips" id="activeCat"></div>
      </div>
    </div>
    <div class="row" style="margin-top:8px">
      <button id="reset" class="btn">Wis filters</button>
    </div>
  </div>

  <div class="panel">
    <div class="row" style="justify-content:space-between">
      <div class="muted" id="count">0 resultaten</div>
      <div class="muted">Sorteer op: Match% (hoog → laag)</div>
    </div>
    <table>
      <thead>
        <tr><th>Naam</th><th>Locaties</th><th>Categorieën</th><th style="width:260px">Match</th></tr>
      </thead>
      <tbody id="results"></tbody>
    </table>
  </div>

  <details class="panel debug" id="debugPanel" style="display:none">
    <summary>Debugdetails</summary>
    <div class="kv" id="dbg"></div>
  </details>
</div>

<script>
/* ===================== CONFIG ===================== */
/* Vervang hieronder met jouw (publieke) Forms/Sheet CSV als je wilt vastzetten */
const DATA_URL_DEFAULT = "https://docs.google.com/spreadsheets/d/e/2PACX-1vQzg4Lc0Ffm3lmtQNSJPa5oPX3BMI0CNvWlhYuqT7u5zrtOlsG4-7urOd51M0TUg7DTvg-CH6GPm4_Q/pub?gid=1507012908&single=true&output=csv";

/* Probeer eerst direct, daarna proxies (om CORS of 403 te omzeilen) */
const PROXIES = [
  (url) => url,
  (url) => "https://cors.isomorphic-git.org/" + url,
  (url) => "https://api.allorigins.win/raw?url=" + encodeURIComponent(url),
];

/* “Hoofdtermen” die we uit kolomnamen halen (fuzzy) */
const HEAD_TOKENS = [
  "Kinder","Geriatrie","Psychosomatisch","CZ","Wervelkolom","Benen","Armen","Specifieke behandelingen"
];

/* ===================== HELPERS ===================== */
function setStatus(msg, isError=false){
  const el = document.getElementById('statusBar');
  el.textContent = msg;
  el.className = isError ? 'status error' : 'status';
}
function parseCSV(text){
  const rows=[]; let row=[], field='', i=0, q=false;
  while(i<text.length){
    const c=text[i];
    if(q){ if(c==='\"'){ if(text[i+1]==='\"'){ field+='\"'; i++; } else { q=false; } } else { field+=c; } }
    else { if(c==='\"'){ q=true; } else if(c===','){ row.push(field); field=''; }
           else if(c==='\n'){ row.push(field); rows.push(row); row=[]; field=''; }
           else if(c!=='\r'){ field+=c; } }
    i++;
  }
  if(field.length||q||row.length){ row.push(field); rows.push(row); }
  return rows;
}
function norm(s){ return String(s||'').trim().toLowerCase(); }
function removeDiacritics(s){ return norm(s).normalize('NFD').replace(/[\u0300-\u036f]/g,''); }
function tokenizeLabel(s){
  const t = removeDiacritics(s).replace(/[^a-z0-9\s]/g,' ').split(/\s+/).filter(Boolean);
  return t.map(w=>{
    if(w.length>4){
      if(w.endsWith('en')) return w.slice(0,-2);   // heupen -> heup; bovenbenen -> bovenbeen
      if(w.endsWith('s'))  return w.slice(0,-1);   // schouders -> schouder
    }
    return w;
  });
}
function jaccard(a,b){ const A=new Set(a),B=new Set(b); const inter=[...A].filter(x=>B.has(x)).length; const uni=new Set([...A,...B]).size||1; return inter/uni; }
function similarLabel(a,b){
  const ta=tokenizeLabel(a), tb=tokenizeLabel(b);
  if(jaccard(ta,tb) >= 0.6) return true;
  const sa=removeDiacritics(a), sb=removeDiacritics(b);
  return sa.includes(sb) || sb.includes(sa);
}
function cleanLabel(s){ return tokenizeLabel(s).map(w=>w[0].toUpperCase()+w.slice(1)).join(' '); }
function splitLoc(v){
  const raw=String(v||'').trim();
  if(!raw) return [];
  return raw.split(/[,;/]| en /i).map(x=>x.trim()).filter(Boolean);
}
function isTruthy(v){
  const s = norm(v);
  if(!s) return false;
  if(['0','nee','false','nvt','-'].includes(s)) return false;
  return true; // ja/x/1/checked/tekst → waar
}

/* ===================== STATE ===================== */
let DATA=[], ALL_LOCS=[], SELECTED_CATS=[], ALL_CATS=[], HEAD_MAP=new Map(), DEBUG={};
const els = {
  locFree:document.getElementById('locFree'),
  locSelect:document.getElementById('locSelect'),
  catInput:document.getElementById('catInput'),
  suggest:document.getElementById('suggest'),
  activeCat:document.getElementById('activeCat'),
  reset:document.getElementById('reset'),
  results:document.getElementById('results'),
  count:document.getElementById('count'),
  refresh:document.getElementById('refresh'),
  debugPanel:document.getElementById('debugPanel'),
  dbg:document.getElementById('dbg'),
  toggleDebug:document.getElementById('toggleDebug'),
};

/* ===================== FETCH ===================== */
async function fetchCSV(url){
  let lastErr;
  for(const wrap of PROXIES){
    const u = wrap(url);
    try{
      setStatus(`Laden: ${u}`);
      const res = await fetch(u, { cache: 'no-store' });
      if(!res.ok) throw new Error(`HTTP ${res.status}`);
      const txt = await res.text();
      setStatus(`Geladen: ${u}`);
      return parseCSV(txt);
    }catch(e){
      lastErr = e;
      console.warn('Fetch poging faalde:', u, e);
    }
  }
  setStatus(`Fout bij laden: ${lastErr?.message || lastErr}`, true);
  throw lastErr || new Error('Failed to fetch');
}

/* ===================== DATA inlezen (zonder taxonomie) ===================== */
function buildData(rows){
  if(!rows || !rows.length) throw new Error('Lege data CSV');
  const header = rows[0].map(h => String(h||''));
  const headerNorm = header.map(h=>removeDiacritics(h).replace(/\s+/g,' ').trim());

  const findCol = (needles) => { for(let i=0;i<headerNorm.length;i++){ if(needles.some(n=>headerNorm[i].includes(n))) return i; } return -1; };

  // robuuste herkenning naam/loc/spec
  const iName = findCol(['naam','naam collega','voor- en achternaam','voornaam','achternaam','collega','medewerker','naam?','naam van collega']);
  const iLoc  = findCol(['locatie','locaties','locatie(s)','op welke locatie','werk je','werkzaam','standplaats','vestiging','waar werk je','op welke locaties']);
  const iSpec = findCol(['specifieke behandelingen','spec beh','specbeh','specifieke','behandelingen (specbeh)','spec-beh','spec behandelingen']);

  if(iName < 0 || iLoc < 0){
    setStatus(`Kolommen niet gevonden: Naam=${iName}, Locatie=${iLoc}. Controleer kopjes in je sheet.`, true);
    throw new Error('Kon verplichte kolommen niet vinden (Naam en Locatie).');
  }

  // alle overige kolommen => mogelijke categorie
  const skip = new Set([iName,iLoc,iSpec].filter(x=>x>=0));
  const categoryCols = [];
  for(let c=0;c<header.length;c++){
    if(skip.has(c)) continue;
    const label = cleanLabel(header[c]);
    if(label) categoryCols.push({index:c,label});
  }

  // bepaal per label welke hoofdterm(en) het waarschijnlijk is (Kinder/Benen/…)
  HEAD_MAP = new Map();
  for(const col of categoryCols){
    const heads = HEAD_TOKENS.filter(h => similarLabel(h, col.label));
    HEAD_MAP.set(col.label, heads); // kan leeg of meerdere zijn
  }

  const out = [];
  const locsSet = new Set();
  const allCategoryLabels = new Set();
  for(let r=1;r<rows.length;r++){
    const row = rows[r]; if(!row || row.length===0) continue;
    const name = (row[iName]||'').toString().trim(); if(!name) continue;

    const locations = splitLoc(row[iLoc]||''); locations.forEach(l=>locsSet.add(l));

    const mains = [];
    for(const col of categoryCols){
      const v = row[col.index];
      if(isTruthy(v)){
        mains.push(col.label);
        allCategoryLabels.add(col.label);
      }
    }

    // Specifieke behandelingen: neem losse termen mee als extra categorieën
    const specs = [];
    if(iSpec >= 0){
      const raw=(row[iSpec]||'').toString().trim();
      if(raw){
        raw.split(',').forEach(p=>{
          const clean = cleanLabel(p);
          if(clean){ specs.push(clean); allCategoryLabels.add(clean); }
        });
      }
    }

    const categories = Array.from(new Set([...mains, ...specs]));
    out.push({ name, locations, categories });
  }

  DATA = out;
  ALL_LOCS = Array.from(locsSet).sort((a,b)=>a.localeCompare(b));
  ALL_CATS = Array.from(allCategoryLabels).sort((a,b)=>a.localeCompare(b));

  DEBUG = {
    rows: rows.length-1,
    cols: header.length,
    nameCol: iName, locCol: iLoc, specCol: iSpec,
    categoryCols: categoryCols.map(c=>c.label),
    headMapSample: Array.from(HEAD_MAP.entries()).slice(0,12).map(([k,v])=>`${k} -> ${v.join('/')}`)
  };
}

/* ===================== TYPEAHEAD ===================== */
function renderSuggestions(term){
  const box = els.suggest; box.innerHTML="";
  const t = norm(term); if(!t){ box.style.display="none"; return; }

  // opties: 1) hoofdtermen (als match), 2) alle categorie-labels
  const headHits = HEAD_TOKENS.filter(h => norm(h).includes(t));
  const catHits  = ALL_CATS.filter(c => norm(c).includes(t)).slice(0,50);

  const items = [
    ...headHits.map(h=>({type:'head', value:h, label:`${h} (hoofdcategorie)`})),
    ...catHits.map(c=>({type:'sub',  value:c, label:c}))
  ];

  if(items.length===0){ box.style.display="none"; return; }

  items.forEach(it=>{
    const row = document.createElement('div');
    row.innerHTML = `<strong>${it.value}</strong> <span class="tag">${it.type==='head'?'hoofdcategorie':'sub'}</span>`;
    row.addEventListener('click', ()=>{
      SELECTED_CATS.push(it);
      els.catInput.value="";
      box.style.display="none";
      renderActiveCats();
      applyFilters();
    });
    box.appendChild(row);
  });
  box.style.display="block";
}
function renderActiveCats(){
  const wrap = els.activeCat; wrap.innerHTML="";
  SELECTED_CATS.forEach((c,i)=>{
    const chip = document.createElement('span');
    chip.className="chip";
    chip.innerHTML = `${c.value} <span class="x" title="verwijderen">×</span>`;
    chip.querySelector('.x').addEventListener('click', ()=>{
      SELECTED_CATS.splice(i,1);
      renderActiveCats();
      applyFilters();
    });
    wrap.appendChild(chip);
  });
}

/* ===================== MATCHING ===================== */
function labelHasHead(label, head){
  const heads = HEAD_MAP.get(label) || [];
  return heads.some(h => h === head);
}
function hasAnyLabelInHead(colleague, head){
  return colleague.categories.some(lbl => labelHasHead(lbl, head));
}
function hasExactLabel(colleague, label){
  return colleague.categories.some(lbl => similarLabel(lbl, label));
}
function matchesLocation(colleague, selected, free){
  let ok = false;
  if(selected.length){
    const set = new Set(colleague.locations.map(x=>norm(x)));
    ok = selected.some(v=>set.has(norm(v)));
  }
  if(!ok && free){
    const t = norm(free);
    ok = colleague.locations.some(l=>norm(l).includes(t));
  }
  return ok;
}

/* Scoring:
   - Gekozen sub-label: 1.0 als fuzzy exact; 0.6 als collega een ander label heeft dat bij dezelfde head hoort; 0 anders
   - Gekozen head:      1.0 als collega ≥1 label heeft dat (fuzzy) aan die head is gekoppeld
   - Locatie (indien ingevuld): +1.0 bij match
*/
function scoreColleague(colleague){
  let points = 0, possible = 0;
  const notes = [];

  for(const f of SELECTED_CATS){
    if(f.type==='sub'){
      possible += 1;
      if(hasExactLabel(colleague, f.value)){
        points += 1.0; notes.push({type:'good', txt:`Sub: ${f.value}`});
      }else{
        // zoek of de gekozen sub een head raakt, en of collega iets in die head heeft
        const heads = HEAD_TOKENS.filter(h => similarLabel(h, f.value));
        const okSameHead = heads.some(h => hasAnyLabelInHead(colleague, h));
        if(okSameHead){
          points += 0.6; notes.push({type:'warn', txt:`Wel ${heads[0]||'zelfde hoofd'}, andere sub`});
        }else{
          notes.push({type:'bad', txt:`Geen ${f.value}`});
        }
      }
    }else if(f.type==='head'){
      possible += 1;
      if(hasAnyLabelInHead(colleague, f.value)){
        points += 1.0; notes.push({type:'good', txt:`Hoofd: ${f.value}`});
      }else{
        notes.push({type:'bad', txt:`Geen ${f.value}`});
      }
    }
  }

  const selLocs = Array.from(els.locSelect.selectedOptions).map(o=>o.value);
  const freeLoc = els.locFree.value.trim();
  if(selLocs.length || freeLoc){
    possible += 1;
    if(matchesLocation(colleague, selLocs, freeLoc)){
      points += 1.0; notes.push({type:'good', txt:`Locatie match`});
    }else{
      notes.push({type:'warn', txt:`Locatie mist`});
    }
  }

  const pct = possible>0 ? Math.round((points/possible)*100) : 0;
  return { pct, notes };
}

/* ===================== RENDER ===================== */
function renderResults(list){
  els.results.innerHTML="";
  els.count.textContent = `${list.length} resultaten`;
  list.forEach(r=>{
    const tr = document.createElement('tr');
    tr.innerHTML = `
      <td><div class="name">${r.name}</div></td>
      <td>${r.locations.map(l=>`<span class="chip">${l}</span>`).join(" ")}</td>
      <td>${r.categories.map(c=>`<span class="chip">${c}</span>`).join(" ")}</td>
      <td>
        <div class="kpi">
          <div style="min-width:46px;font-weight:600">${r._score.pct}%</div>
          <div class="meter" style="flex:1"><div class="bar" style="width:${r._score.pct}%"></div></div>
        </div>
        <div style="margin-top:6px">
          ${r._score.notes.map(n=>`<span class="badge ${n.type}">${n.txt}</span>`).join(" ")}
        </div>
      </td>`;
    els.results.appendChild(tr);
  });
}
function applyFilters(){
  const res = DATA.map(d=>({...d, _score:scoreColleague(d)}))
                  .sort((a,b)=> b._score.pct - a._score.pct);
  renderResults(res);
}

/* ===================== LOCATIES ===================== */
function populateLocations(){
  const sel = els.locSelect; sel.innerHTML = "";
  ALL_LOCS.forEach(l=>{
    const o = document.createElement('option');
    o.value=l; o.textContent=l;
    sel.appendChild(o);
  });
}

/* ===================== DEBUG ===================== */
function renderDebug(){
  const D = els.dbg; D.innerHTML = "";
  const rows = [
    ["Aantal regels (data)", DEBUG.rows ?? "-"],
    ["Aantal kolommen", DEBUG.cols ?? "-"],
    ["Kolom Naam index", DEBUG.nameCol ?? "-"],
    ["Kolom Locatie index", DEBUG.locCol ?? "-"],
    ["Kolom SpecBeh index", DEBUG.specCol ?? "-"],
    ["Categorie-kolommen (alle)", (DEBUG.categoryCols||[]).join(", ") || "-"],
    ["Head-mapping (voorbeeld)", (DEBUG.headMapSample||[]).join(" | ") || "-"],
  ];
  rows.forEach(([k,v])=>{
    const kEl = document.createElement('div'); kEl.textContent = k;
    const vEl = document.createElement('div'); vEl.textContent = v;
    D.appendChild(kEl); D.appendChild(vEl);
  });
}

/* ===================== LADEN ===================== */
async function loadAll(){
  try{
    setStatus('Data laden…');
    const dataRows = await fetchCSV(DATA_URL_DEFAULT);
    buildData(dataRows);
    populateLocations();
    applyFilters();
    renderDebug();
    setStatus('Data geladen.');
  }catch(e){
    setStatus('Fout bij laden: ' + (e.message||e), true);
  }
}

/* ===================== EVENTS ===================== */
els.reset.addEventListener('click', ()=>{
  els.locFree.value="";
  Array.from(els.locSelect.options).forEach(o=>o.selected=false);
  SELECTED_CATS.length=0;
  els.activeCat.innerHTML="";
  applyFilters();
});
els.catInput.addEventListener('input', e=>renderSuggestions(e.target.value));
document.addEventListener('click', (e)=>{
  if(!els.suggest.contains(e.target) && e.target!==els.catInput){
    els.suggest.style.display="none";
  }
});
els.locFree.addEventListener('input', applyFilters);
els.locSelect.addEventListener('change', applyFilters);
els.refresh.addEventListener('click', loadAll);
els.toggleDebug.addEventListener('click', ()=>{
  const vis = els.debugPanel.style.display !== "none";
  els.debugPanel.style.display = vis ? "none" : "block";
});

/* ===================== INIT + AUTO REFRESH ===================== */
loadAll();
const AUTO_REFRESH_MS = 24 * 60 * 60 * 1000; // 24u
setInterval(() => { loadAll(); }, AUTO_REFRESH_MS);
</script>
</body>
</html>
