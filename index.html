<script>
// ===== CONFIG: KOLOMNAMEN (exact zoals in je sheet) =====
const NAME_KEY = "Wat is je voor- en achternaam?";
const LOC_KEY  = "Op welke locatie(s) werk je? Let op: meerdere locaties mogelijk";

const HEAD_KEYS = [
  "Kinder (KI)",
  "Geriatrie (GE)",
  "Psychosomatisch (PS)",
  "CZ (Chronische Zorg)",
  "Wervelkolom (WK)",
  "Benen (BE)",
  "Armen (AR)"
];

const SPEC_KEY = "Specifieke behandelingen (SpecBeh)";

// ========= JOUW OPENSHEET-LINK IS HIÉR INGEBOUWD ==========
const DEFAULT_OPENSHEET_URL =
  "https://opensheet.elk.sh/1Lixz4zd1EfYyRpqMB-5rN5yptCWJ2hxHboDiMulot10/1507012908";
// ===========================================================

// STATE
let RAW_ROWS = [];
let RECORDS = [];
let ALL_LOCATIONS = [];
let ALL_SUBS = [];
let HEAD_META = [];

// Elements
const statusEl       = document.getElementById("status");
const locQueryInput  = document.getElementById("locQuery");
const locList        = document.getElementById("locList");
const subQueryInput  = document.getElementById("subQuery");
const nameQueryInput = document.getElementById("nameQuery");
const headChipsWrap  = document.getElementById("headChips");
const subChipsWrap   = document.getElementById("subChips");
const hideZeroCb     = document.getElementById("hideZero");
const activeFiltersEl= document.getElementById("activeFilters");
const resultCountEl  = document.getElementById("resultCount");
const resultsBody    = document.getElementById("resultsBody");
const clearFiltersBtn= document.getElementById("clearFilters");
const exportBtn      = document.getElementById("exportBtn");

// Helper
function setStatus(msg, warn=false){
  statusEl.textContent = msg || "";
  statusEl.className = "status " + (warn ? "warn" : "muted");
}

function norm(s){
  return String(s || "")
    .toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g,"")
    .replace(/\s+/g," ")
    .trim();
}

function splitLocations(v){
  const raw = String(v||"").trim();
  if(!raw) return [];
  return raw.split(/,|\/|;| en /i).map(s=>s.trim()).filter(Boolean);
}
function splitSubs(v){
  const raw = String(v||"").trim();
  if(!raw) return [];
  return raw.split(",").map(s=>s.trim()).filter(Boolean);
}

function levenshtein(a,b){
  a = norm(a); b = norm(b);
  const m=a.length, n=b.length;
  if(!m) return n;
  if(!n) return m;
  const dp = [];
  for(let i=0;i<=m;i++){ dp[i]=[i]; }
  for(let j=1;j<=n;j++){ dp[0][j]=j; }

  for(let i=1;i<=m;i++){
    for(let j=1;j<=n;j++){
      const cost = a[i-1]===b[j-1] ? 0 : 1;
      dp[i][j] = Math.min(
        dp[i-1][j]+1,
        dp[i][j-1]+1,
        dp[i-1][j-1]+cost
      );
    }
  }
  return dp[m][n];
}

function fuzzyScore(q,t){
  q = norm(q); t = norm(t);
  if(!q || !t) return 0;
  if(t.includes(q) || q.includes(t)) return 1;
  const d = levenshtein(q,t);
  const maxLen = Math.max(q.length,t.length);
  const sim = 1 - d/maxLen;
  if(sim>=0.8) return 1;
  if(sim>=0.6) return 0.6;
  if(sim>=0.45) return 0.3;
  return 0;
}
function maxFuzzyScore(q,arr){
  if(!q) return 0;
  let best=0;
  for(const t of arr){
    const s=fuzzyScore(q,t);
    if(s>best) best=s;
    if(best===1) break;
  }
  return best;
}

// RECORDS bouwen
function buildRecords(rows){
  RAW_ROWS = rows;
  RECORDS = [];
  ALL_LOCATIONS=[];
  ALL_SUBS=[];
  const subsSet=new Set();
  HEAD_META = HEAD_KEYS.map(k=>({key:k,label:k}));

  for(const row of rows){
    const name = (row[NAME_KEY]||"").trim();
    if(!name) continue;

    const locations = splitLocations(row[LOC_KEY]||"");

    const heads=[];
    const subsByHead={};
    const allSubs=[];

    HEAD_KEYS.forEach(headKey=>{
      const cell=row[headKey];
      const subs = splitSubs(cell);
      if(subs.length){
        heads.push(headKey);
        subsByHead[headKey]=subs;
        subs.forEach(s=>subsSet.add(s));
        allSubs.push(...subs);
      }
    });

    const spec = splitSubs(row[SPEC_KEY]||"");
    spec.forEach(s=>{ subsSet.add(s); allSubs.push(s); });

    ALL_LOCATIONS.push(...locations);

    RECORDS.push({
      name,
      locations,
      heads,
      subsByHead,
      allSubs
    });
  }

  ALL_LOCATIONS = Array.from(new Set(ALL_LOCATIONS)).sort();
  ALL_SUBS = Array.from(subsSet).sort();

  populateLocationList();
  renderHeadChips();
  renderSubChips();
  applyFilters();
}

function populateLocationList(){
  locList.innerHTML="";
  ALL_LOCATIONS.forEach(loc=>{
    const opt=document.createElement("option");
    opt.value=loc;
    opt.textContent=loc;
    locList.appendChild(opt);
  });
}

function renderHeadChips(){
  headChipsWrap.innerHTML="";
  HEAD_META.forEach(h=>{
    const chip=document.createElement("span");
    chip.className="chip chip-toggle";
    chip.textContent=h.label;
    chip.dataset.key=h.key;
    chip.onclick=()=>{ chip.classList.toggle("active"); applyFilters(); };
    headChipsWrap.appendChild(chip);
  });
}
function selectedHeads(){
  return [...headChipsWrap.querySelectorAll(".chip-toggle.active")]
    .map(el=>el.dataset.key);
}

function renderSubChips(){
  subChipsWrap.innerHTML="";
  ALL_SUBS.slice(0,15).forEach(sub=>{
    const chip=document.createElement("span");
    chip.className="chip chip-small chip-toggle";
    chip.textContent=sub;
    chip.onclick=()=>{ subQueryInput.value=sub; applyFilters(); };
    subChipsWrap.appendChild(chip);
  });
}
function selectedLocations(){
  return [...locList.selectedOptions].map(o=>o.value);
}

// MATCHBEREKENING
function computeMatchScore(rec,filters){
  const {locQuery,locList,heads,subQuery} = filters;
  const W_LOC=0.2, W_HEAD=0.3, W_SUB=0.5;

  if(!locQuery && !locList.length && !heads.length && !subQuery) return 0;

  let maxScore=0, locScore=0, headScore=0, subScore=0;

  if(locQuery || locList.length){
    maxScore+=W_LOC;
    let s=0;
    if(locQuery) s=Math.max(s,maxFuzzyScore(locQuery,rec.locations));
    if(locList.length){
      const nsel=locList.map(norm);
      const nrec=rec.locations.map(norm);
      if(nsel.some(x=>nrec.includes(x))) s=Math.max(s,1);
    }
    locScore=W_LOC*s;
  }
  if(heads.length){
    maxScore+=W_HEAD;
    const set=new Set(rec.heads);
    headScore = heads.some(h=>set.has(h)) ? W_HEAD : 0;
  }
  if(subQuery){
    maxScore+=W_SUB;
    const s=maxFuzzyScore(subQuery,rec.allSubs);
    subScore=W_SUB*s;
  }

  if(locScore>0 && subScore>=W_SUB*0.9) return 100;
  if(!locQuery && !locList.length && !heads.length && subScore>=W_SUB*0.9) return 100;

  if(maxScore===0) return 0;
  return Math.round((locScore+headScore+subScore)/maxScore * 100);
}

// Toepassen & tonen
function applyFilters(){
  const filters={
    locQuery:locQueryInput.value.trim(),
    locList:selectedLocations(),
    heads:selectedHeads(),
    subQuery:subQueryInput.value.trim(),
    nameQuery:nameQueryInput.value.trim()
  };

  const hideZero=hideZeroCb.checked;

  const enriched = RECORDS.map(rec=>{
    let score=computeMatchScore(rec,filters);
    if(filters.nameQuery){
      const hay=[rec.name,...rec.locations,...rec.heads,...rec.allSubs].join(" | ");
      const s=fuzzyScore(filters.nameQuery,hay);
      if(s===0) score=-1;
      else score=Math.min(100,score+Math.round(20*s));
    }
    return {rec,score};
  });

  const filtered = enriched
    .filter(x=>x.score>=0)
    .filter(x=>!hideZero || x.score>0)
    .sort((a,b)=>b.score - a.score || a.rec.name.localeCompare(b.rec.name,"nl"));

  renderResults(filtered);
}

function renderResults(list){
  resultsBody.innerHTML="";
  list.forEach(({rec,score})=>{
    const tr=document.createElement("tr");

    const tdName=document.createElement("td");
    tdName.innerHTML=`<div class="name">${rec.name}</div><div class="score-pill">Match: ${score}%</div>`;

    const tdLoc=document.createElement("td");
    tdLoc.innerHTML=rec.locations.map(l=>`<span class="chip chip-small">${l}</span>`).join(" ");

    const tdCat=document.createElement("td");
    const parts=[];
    rec.heads.forEach(h=>{
      const subs=rec.subsByHead[h]||[];
      if(subs.length){
        parts.push(
          `<div><span class="chip chip-small">${h}</span> ${
            subs.map(s=>`<span class="chip chip-small">${s}</span>`).join(" ")
          }</div>`
        );
      }
    });
    tdCat.innerHTML = parts.join("");
    tr.append(tdName,tdLoc,tdCat);
    resultsBody.appendChild(tr);
  });

  resultCountEl.textContent=`${list.length} resultaat${list.length===1?"":"en"}`;
}

// CSV
function exportCurrentSelection(){
  const rows=[["Naam","Locaties","Hoofdcategorieën","Subcategorieën"]];
  const table=[...resultsBody.querySelectorAll("tr")];
  table.forEach(tr=>{
    const name = tr.children[0].querySelector(".name").textContent;
    const locs = [...tr.children[1].querySelectorAll(".chip")].map(c=>c.textContent).join(" | ");
    const cats = tr.children[2].innerText.replace(/\n+/g," | ");
    rows.push([name,locs,cats]);
  });

  const csv = rows.map(r=>r.map(x=>`"${x.replace(/"/g,'""')}"`).join(",")).join("\n");
  const blob=new Blob([csv],{type:"text/csv"});
  const a=document.createElement("a");
  a.href=URL.createObjectURL(blob);
  a.download="monne_zoekresultaten.csv";
  a.click();
}

// EVENTS
[locQueryInput,subQueryInput,nameQueryInput].forEach(input=>{
  input.addEventListener("input",applyFilters);
});
locList.addEventListener("change",applyFilters);
hideZeroCb.addEventListener("change",applyFilters);
clearFiltersBtn.addEventListener("click",()=>{
  locQueryInput.value="";
  subQueryInput.value="";
  nameQueryInput.value="";
  hideZeroCb.checked=false;
  [...locList.options].forEach(o=>o.selected=false);
  [...headChipsWrap.querySelectorAll(".chip-toggle.active")].forEach(c=>c.classList.remove("active"));
  applyFilters();
});
exportBtn.addEventListener("click",exportCurrentSelection);

// ===== AUTOMATISCH LADEN BIJ START =====
(async function autoLoad(){
  setStatus("Laden van Google Sheet...", false);
  try{
    const res = await fetch(DEFAULT_OPENSHEET_URL);
    const json = await res.json();
    setStatus("Data geladen.", false);
    buildRecords(json);
  } catch(e){
    console.error(e);
    setStatus("Fout: kon de sheet niet laden.", true);
  }
})();
</script>
